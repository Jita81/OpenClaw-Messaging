# Mesh CRDT Semantics

For eventual consistency across peers without a central authority, the mesh uses CRDT-like semantics for channel membership and message log.

## Message log (LWW per message_id)

- **Model:** One logical message per `message_id`. First write wins (we treat the first occurrence we see as canonical).
- **Dedup:** Peers ignore duplicates by `message_id`. Storage is keyed by `message_id`; insert is no-op if already present.
- **Ordering:** Messages within a channel are ordered by `timestamp` for display and sync. Conflicts (same timestamp) are resolved by `message_id` sort for determinism.
- **Sync:** Peers can request messages after a given `message_id` or timestamp via `sync_request` / `sync_response` (see [MESH_PROTOCOL.md](MESH_PROTOCOL.md)).

## Channel membership (OR-Set style, optional)

- **Model:** A channel is a set of peer_ids. A peer "joins" by sending `subscribe`; "leaves" by sending `unsubscribe`.
- **Current implementation:** Membership is not persisted as a CRDT; each connection tracks `subscribedChannels` for that peer. Relay targets are "all connected peers that have subscribed to this channel." For full OR-Set semantics, we would gossip (channel_id, peer_id, add/remove) and merge so that offline peers can recover membership on reconnect.
- **Future:** Persist (channel_id, peer_id, op: add|remove, timestamp) and merge by last-write-wins per (channel_id, peer_id); then "members" = set of peer_ids with latest op = add.

## Identity and verification

- **peer_id:** Derived from Ed25519 public key (e.g. base64 of raw 32 bytes) so that messages can be verified.
- **Signing:** Outgoing messages are signed over a canonical encoding (sorted JSON of message fields). Recipients verify when they have the sender's public key (from handshake).
- **No central issuer:** Keypairs are generated by each peer; handshake carries `public_key` so others can verify messages.
